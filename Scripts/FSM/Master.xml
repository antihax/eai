<?xml version="1.0" encoding="utf-8"?>
<hfsm name="Targetting">
	<subs>
		<!-- <file path="Weapon.xml"/> -->
	</subs>
	<states default="Idle">
		<state name="Idle">
			<variables>
			</variables>
			<editor_data>
				<position x="551" y="94" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				unit.UseTargetting();
			</event_entry>
			<event_exit></event_exit>
			<event_update>
                return EXIT;
            </event_update>
		</state>
		<state name="GoingToTarget">
			<variables>
				<variable name="time" type="float" />
				<variable name="target" type="eAITargetInformation" />
			</variables>
			<editor_data>
				<position x="551" y="94" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				unit.UseTargetting();
			</event_entry>
			<event_exit></event_exit>
			<event_update>
				target.Update(unit.GetGroup());

                return EXIT;
            </event_update>
		</state>
		<state name="TraversingWaypoints">
			<variables>
				<variable name="path" type="array<vector>" />
				<variable name="behaviour" type="eAIWaypointBehavior" />
				<variable name="backtracking" type="bool" />
				<variable name="index" type="int" />
			</variables>
			<editor_data>
				<position x="551" y="94" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				path = unit.GetGroup().GetWaypoints();
				behaviour = unit.GetGroup().GetWaypointBehaviour();
			</event_entry>
			<event_exit></event_exit>
			<event_update>
				float distance = vector.DistanceSq(unit.GetPosition(), path[index]);
				if (distance &lt; 10.0 &amp;&amp; distance &gt; 0.01)
				{
					if (backtracking) index--;
					else index++;
				}

				if (index &lt; 0) 
				{
					if (behaviour == eAIWaypointBehavior.REVERSE)
					{
						backtracking = false;
						index = 1;
					}
				}
				else if (index &gt; path.Count())
				{
					if (behaviour == eAIWaypointBehavior.REVERSE)
					{
						backtracking = true;
						index = path.Count() - 2;
					} 
					else if (behaviour == eAIWaypointBehavior.LOOP)
					{
						backtracking = false;
						index = 0;
					}
				}

				index = Math.Clamp(index, 0, path.Count());

				unit.OverridePosition(path[index]);

                return EXIT;
            </event_update>
		</state>
		<state name="Weapon_Reloading">
			<variables>
				<variable name="magazine" type="EntityAI" />
				<variable name="weapon" type="EntityAI" />
			</variables>
			<editor_data>
				<position x="333" y="374" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				unit.RaiseWeapon(true);
				unit.ReloadWeaponAI(weapon, magazine);
			</event_entry>
			<event_exit>
				unit.RaiseWeapon(false);
			</event_exit>
			<event_update>
				if (!unit.GetWeaponManager()) return EXIT;

				if (unit.GetWeaponManager().IsRunning()) return CONTINUE;

                return EXIT;
            </event_update>
		</state>
		<state name="Weapon_GoingToPosition">
			<variables>
				<variable name="time" type="float" />
				<variable name="position" type="vector" />
			</variables>
			<editor_data>
				<position x="333" y="374" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				time = 0;

				PGFilter filter = new PGFilter();

				int inFlags = PGPolyFlags.WALK | PGPolyFlags.DOOR | PGPolyFlags.INSIDE | PGPolyFlags.JUMP_OVER;
				int exFlags = PGPolyFlags.DISABLED | PGPolyFlags.SWIM | PGPolyFlags.SWIM_SEA | PGPolyFlags.SPECIAL | PGPolyFlags.JUMP | PGPolyFlags.CLIMB | PGPolyFlags.CRAWL | PGPolyFlags.CROUCH;

				filter.SetFlags(inFlags, exFlags, PGPolyFlags.NONE);
				filter.SetCost(PGAreaType.BUILDING, 0.0);
				filter.SetCost(PGAreaType.TREE, 0.0);

				position = unit.GetPosition();
				GetGame().GetWorld().GetAIWorld().SampleNavmeshPosition(position, 10.0, filter, position)

				unit.OverridePosition(position);
			</event_entry>
			<event_exit>
			</event_exit>
			<event_update>
				time += DeltaTime;

				return EXIT;
            </event_update>
		</state>
		<state name="Weapon_Firing">
			<variables>
			</variables>
			<editor_data>
				<position x="333" y="374" />
				<size width="150" height="40" />
			</editor_data>
			<event_entry>
				unit.RaiseWeapon(true);
				unit.UpdateAimArbitration();
			</event_entry>
			<event_exit>
				unit.StopAimArbitration();
				unit.RaiseWeapon(false);

				unit.UseTargetting();
			</event_exit>
			<event_update>
				if (unit.CanFire()) unit.DryFire();

				return EXIT;
            </event_update>
		</state>
	</states>
	<transitions>
		<transition>
			<editor_data>
				<position_source x="1" y="0.3" />
				<position_destination x="0" y="0.3" />
			</editor_data>
			<guard>
                auto group = unit.GetGroup();
                if (!group) return FAIL;

                auto leader = group.GetLeader();
                if (!leader) return FAIL;

				// continue traversing the waypoints since we have no leader
                if (leader == unit) return FAIL;

				dst.target = group.GetTargetInformation();
                if (!dst.target) return FAIL;

                vector pos = dst.target.GetPosition(unit);
                if (vector.Distance(pos, unit.GetPosition()) &gt; 50.0) return FAIL;

				dst.target.AddAI(unit);

                return SUCCESS;
            </guard>
			<event name="" />
			<from_state name="Idle" />
			<to_state name="GoingToTarget" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="0" y="0.7" />
				<position_destination x="1" y="0.7" />
			</editor_data>
			<guard>
                auto group = unit.GetGroup();
                if (!group) return FAIL;

                auto leader = group.GetLeader();
                if (!leader) return SUCCESS;

				// we are the leader so we traverse the waypoints
                if (leader == unit) return SUCCESS;

				auto target = group.GetTargetInformation();
                if (!target) return SUCCESS;

                return SUCCESS;
            </guard>
			<event name="" />
			<from_state name="Idle" />
			<to_state name="TraversingWaypoints" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="0" y="0.7" />
				<position_destination x="1" y="0.7" />
			</editor_data>
			<guard>
                auto group = unit.GetGroup();
                if (group) return FAIL;

                auto leader = group.GetLeader();
                if (leader) return FAIL;

				auto target = group.GetTargetInformation();
                if (target) return FAIL;

                return SUCCESS;
            </guard>
			<event name="" />
			<from_state name="TraversingWaypoints" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="0" y="0.7" />
				<position_destination x="1" y="0.7" />
			</editor_data>
			<guard>
                auto group = unit.GetGroup();
                if (group) return FAIL;

                auto leader = group.GetLeader();
                if (leader) return FAIL;

				auto target = group.GetTargetInformation();
                if (target)
				{
					vector pos = target.GetPosition(unit);
					if (vector.Distance(pos, unit.GetPosition()) &gt; 50.0)
					{
						target.RemoveAI(unit);
						return SUCCESS;
					}

					return FAIL;
				}

                return SUCCESS;
            </guard>
			<event name="" />
			<from_state name="GoingToTarget" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="0" y="0.7" />
				<position_destination x="1" y="0.7" />
			</editor_data>
			<guard>
				Weapon weapon_in_hands;
				if (!Class.CastTo(weapon_in_hands, unit.GetItemInHands())) return FAIL;

				int mi = weapon_in_hands.GetCurrentMuzzle();
				Magazine mag = weapon_in_hands.GetMagazine(mi);
				if (mag &amp;&amp; mag.GetAmmoCount() &gt; 0) return FAIL;

				dst.magazine = unit.GetMagazineToReload(weapon_in_hands);
				dst.weapon = weapon_in_hands;
				if (!dst.magazine || !dst.weapon) return FAIL;

				// don't move to the state if the action manager can't be initiated.
				if (!unit.GetActionManager() || unit.GetActionManager().GetRunningAction()) return FAIL;
				
				return SUCCESS;
            </guard>
			<event name="" />
			<from_state name="" />
			<to_state name="Weapon_Reloading" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="0" y="0.7" />
				<position_destination x="1" y="0.7" />
			</editor_data>
			<guard>
                if (unit.GetThreatToSelf() &gt; 0.4) return SUCCESS;

                return FAIL;
            </guard>
			<event name="" />
			<from_state name="TraversingWaypoints" />
			<to_state name="Weapon_GoingToPosition" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="0" y="0.7" />
				<position_destination x="1" y="0.7" />
			</editor_data>
			<guard>
                if (unit.GetThreatToSelf() &gt; 0.4) return SUCCESS;

                return FAIL;
            </guard>
			<event name="" />
			<from_state name="GoingToTarget" />
			<to_state name="Weapon_GoingToPosition" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="0" y="0.7" />
				<position_destination x="1" y="0.7" />
			</editor_data>
			<guard>
				if (vector.Distance(unit.GetPosition(), src.position) &gt; 1.0) return FAIL;

				return SUCCESS;
            </guard>
			<event name="" />
			<from_state name="Weapon_GoingToPosition" />
			<to_state name="Weapon_Firing" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="0" y="0.7" />
				<position_destination x="1" y="0.7" />
			</editor_data>
			<guard>
				auto target = unit.GetTarget();
				if (!target) return FAIL;

				if (vector.Distance(unit.GetPosition(), target.GetPosition(unit)) &gt; 10.0) return SUCCESS;

				return FAIL;
            </guard>
			<event name="" />
			<from_state name="Weapon_Firing" />
			<to_state name="Weapon_GoingToPosition" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="0" y="0.7" />
				<position_destination x="1" y="0.7" />
			</editor_data>
			<guard>
                if (unit.GetThreatToSelf() &gt; 0.4) return SUCCESS;

                return FAIL;
            </guard>
			<event name="" />
			<from_state name="Weapon_Reloading" />
			<to_state name="Weapon_GoingToPosition" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="0" y="0.7" />
				<position_destination x="1" y="0.7" />
			</editor_data>
			<guard>
                if (unit.GetThreatToSelf() &lt; 0.4) return SUCCESS;

                return FAIL;
            </guard>
			<event name="" />
			<from_state name="Weapon_Firing" />
			<to_state name="Idle" />
		</transition>
		<transition>
			<editor_data>
				<position_source x="0" y="0.7" />
				<position_destination x="1" y="0.7" />
			</editor_data>
			<guard>
                return SUCCESS;
            </guard>
			<event name="" />
			<from_state name="Weapon_Reloading" />
			<to_state name="Idle" />
		</transition>
	</transitions>
</hfsm>